배열을 빅오 통해서 판단해보고 객체와 비교했을때 성능이 어떤지 보자!
배열에 가장 중요한 점은 정렬이 되어 있다는 것이다. 정렬되어 있는 기준이 있다. 그냥 한 뭉치로 있는 객체와는 다르다.
그렇기 때문에 배열은 대부분 정렬되어 있는 데이터를 위해서 사용한다. 정렬되어 있는 것이 필요 없다면 배열을 사용하지 않는것이 좋다.
정렬되어 있는 데이터가 필요할때 배열을 사용할 수 있지만 성능을 희생해야 할 수도 있다. 특히 입력과 제거를 할 때 그렇다.
배열과 관련된 연산에 대해 빅오 표기법을 확인해 보자

삽입 - 상황에 따에 따라 다름
제거 - 상황에 따에 따라 다름
탐색 - O(N)
접근 - O(1)

접근은 객체와 동일하게 상수시간을 갖는다. 사람들이 가장 많이 하는 오해가 만약 배열의 요소가 10000개가 있는 배열이 있고 3000번째 요소에 접근하려고 했을때
자바스크립트는 모든 요소를 하나씩 지나가면서 3000번까지 숫자를 세고 있다가 원하는 요소에 도착했을 때 그것을 반환해주는것이 아니다!!!
배열의 요소마다 바로 갈 수 있는 지름길이 있다고 생각하면 될 것이다. 그렇기 때문에 접근에 있어서 배열이 얼마나 긴지는 중요하지 않다.
마지막 아이템이든 중간 아이템이든 혹은 처음에 있든 상수 시간이다!!

삽입과 제거는 삽입과 제거가 되는 위치에 따라 성능이 다르다고 했다. 그 이유는 무엇일까?
배열의 각 요소는 각기 index를 가지고 있다. 만약 배열의 맨 마지막 요소 뒤에 새로운 요소를 추가한다면? O(1) 시간이 걸릴것이다. 마지막 요소 다음에 인덱스와 요소만 추가하면 되기 떄문이다. 그런데 제일 앞에 넣는다면?? 원래 존재하던 배열 요소들의 인덱스가 하나씩 뒤로 밀리게 될 것이고 배열의 길이 만큼 새롭게 index번호가 달라질 것이다. 그렇다면 O(N)시간 복잡도가 걸리게 될 것이다. 추가뿐만 아니라 제거도 가장 앞에서 하는것이 문제이다. 원리는 동일하다.

이번에는 배열의 메서드들의 빅오에 대해서 알아보자!

push - O(1)
pop - O(1)
shift - O(N)
unshift - O(N)
concat - O(N)
slice - O(N)
splice - O(N)
sort - - O(N\*log N)
forEach/map/filter/reduce/etc - O(N)
